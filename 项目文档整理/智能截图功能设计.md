# 智能截图功能设计文档

## 📋 文档信息

- **功能名称**: 视频取证智能截图系统
- **创建日期**: 2026-01-22
- **状态**: 设计阶段
- **优先级**: 高

---

## 🎯 功能概述

在视频取证过程中，自动识别视频内容并智能截取关键画面，用于证明侵权视频的来源和内容。

### 核心目标
**让看的人一眼就知道这个视频是啥、是谁发的**

---

## 📝 需求分析

### 客户需求来源

以下是与季老师的对话记录：

```
二进制刀仔: @知产取证-季老师 你抖音视频那里截屏的逻辑是什么？
二进制刀仔: 必须有人物出镜？

知产取证-季老师: 截图，主要是为了让看的人一眼就知道这个视频是啥、是谁发的

知产取证-季老师: 有人物脸，尽量截一张正面的、清楚的大头像，能看清是谁的脸

知产取证-季老师: 如果视频里没人脸：就挑视频里最独特、最清楚的几个画面来截

知产取证-季老师: 比如开头、中间部分、或者结尾的落款。要让人一看这几张图，就知道这确实是那个视频

郑骑锋律师(专利商标著作权-诉讼): 侵权视频录制应该要录制完整吧，可以加速播放

知产取证-季老师: 截图一般3-5张左右  没有固定

知产取证-季老师: 是的 录制完整

二进制刀仔: 视频要录制完整对吧，期间截图
```

### 需求总结

#### 1️⃣ 有人物脸的情况
- ✅ 尽量截一张**正面的、清楚的大头像**
- ✅ 能看清是谁的脸
- ✅ 人脸要清晰、正面、大小合适

#### 2️⃣ 没有人脸的情况
- ✅ 挑视频里**最独特、最清楚**的几个画面
- ✅ 比如**开头、中间部分、结尾的落款**
- ✅ 让人一看这几张图，就知道这确实是那个视频

#### 3️⃣ 数量和流程
- ✅ 截图一般**3-5张**左右，没有固定
- ✅ **视频要录制完整**
- ✅ **期间截图**（在录制过程中进行截图）

---

## 🔍 技术需求分析

### 核心技术需求

1. **人脸检测** - 检测画面中是否有人脸
2. **人脸质量评估** - 判断人脸是否正面、清晰、大小合适
3. **画面清晰度检测** - 判断画面是否清晰
4. **画面独特性检测** - 判断画面是否独特（与其他画面不同）
5. **时间分布控制** - 确保开头、中间、结尾都有截图
6. **实时截屏** - 在视频播放过程中截取画面

---

## 🛠️ 技术方案对比

### 方案1: Google ML Kit ⭐⭐⭐⭐⭐ (推荐)

**官方文档**: https://developers.google.com/ml-kit

#### 优点
- ✅ **完全免费** - Google官方提供
- ✅ **离线可用** - 不需要网络
- ✅ **准确度高** - Google AI技术
- ✅ **易于集成** - 几行代码即可使用
- ✅ **性能优秀** - 针对移动端优化

#### 包含功能
1. **Face Detection** - 人脸检测
   - 检测人脸位置和大小
   - 检测人脸角度(左右转头、上下点头)
   - 检测眼睛睁开概率
   - 检测微笑概率
   - 检测人脸关键点(眼睛、鼻子、嘴巴等)

2. **Image Labeling** - 图像标注
   - 识别画面中的物体
   - 识别场景类型

3. **Text Recognition** - 文字识别
   - 识别画面中的文字
   - 可用于检测落款、品牌名等

#### 依赖配置
```gradle
dependencies {
    implementation 'com.google.mlkit:face-detection:16.1.5'
    implementation 'com.google.mlkit:image-labeling:17.0.7'
    implementation 'com.google.mlkit:text-recognition:16.0.0'
}
```

#### 适用场景
- ✅ 检测人脸是否正面
- ✅ 检测人脸是否清晰(眼睛睁开)
- ✅ 检测人脸大小
- ✅ 完全满足客户需求

---

### 方案2: OpenCV ⭐⭐⭐⭐

**官方文档**: https://opencv.org/

#### 优点
- ✅ **功能强大** - 图像处理全能
- ✅ **开源免费** - MIT许可证
- ✅ **社区活跃** - 大量教程和示例
- ✅ **性能优秀** - C++底层,速度快

#### 包含功能
1. **人脸检测** - Haar Cascade / DNN
2. **画面清晰度检测** - Laplacian算子
3. **画面对比** - 直方图对比、特征点匹配
4. **图像增强** - 锐化、去噪等

#### 依赖配置
```gradle
dependencies {
    implementation 'org.opencv:opencv:4.8.0'
}
```

#### 适用场景
- ✅ 画面清晰度检测
- ✅ 画面独特性检测(对比相似度)
- ✅ 高级图像处理
- ✅ 补充ML Kit的不足

---

### 方案3: TensorFlow Lite ⭐⭐⭐

**官方文档**: https://www.tensorflow.org/lite

#### 优点
- ✅ **自定义模型** - 可训练专用模型
- ✅ **性能优秀** - 针对移动端优化
- ✅ **功能强大** - 可实现复杂AI功能

#### 缺点
- ❌ **需要训练** - 需要大量数据和时间
- ❌ **复杂度高** - 学习成本高
- ❌ **不够灵活** - 模型固定后难以调整

#### 适用场景
- ⚠️ 需要识别特定人物
- ⚠️ 需要识别特定商标/Logo
- ⚠️ 需要复杂的图像分类

#### 建议
**不推荐**,因为ML Kit已经足够强大,无需自己训练模型

---

### 方案4: 云端API ⭐⭐

#### Google Cloud Vision API
- **功能**: 人脸检测、物体识别、文字识别
- **价格**: 前1000次/月免费,之后$1.5/1000次
- **缺点**: 需要网络,有延迟,有成本

#### 阿里云视觉智能
- **功能**: 人脸识别、图像分析
- **价格**: 按调用次数收费
- **缺点**: 需要网络,有成本

#### 建议
**不推荐**,因为:
- ❌ 需要网络连接
- ❌ 有延迟
- ❌ 有成本
- ❌ ML Kit免费且离线

---

## 📊 技术方案对比表

| 技术方案 | 人脸检测 | 清晰度检测 | 相似度对比 | 成本 | 难度 | 推荐度 |
|---------|---------|-----------|-----------|------|------|--------|
| **ML Kit** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 免费 | 简单 | ⭐⭐⭐⭐⭐ |
| **OpenCV** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 免费 | 中等 | ⭐⭐⭐⭐ |
| **TensorFlow Lite** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 免费 | 困难 | ⭐⭐⭐ |
| **云端API** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 付费 | 简单 | ⭐⭐ |
| **自定义算法** | ❌ | ⭐⭐⭐ | ⭐⭐⭐ | 免费 | 简单 | ⭐⭐⭐⭐ |

---

## 🎯 推荐方案

### 最佳方案: ML Kit + 自定义算法

```
┌─────────────────────────────────────┐
│         智能截图系统                 │
├─────────────────────────────────────┤
│                                     │
│  1. Google ML Kit                   │
│     ├─ 人脸检测                     │
│     ├─ 人脸角度检测                 │
│     ├─ 人脸大小检测                 │
│     └─ 眼睛睁开检测                 │
│                                     │
│  2. 自定义算法                      │
│     ├─ 画面清晰度检测               │
│     ├─ 画面相似度对比               │
│     ├─ 评分系统                     │
│     ├─ 时间分布策略                 │
│     └─ 最佳画面选择                 │
│                                     │
└─────────────────────────────────────┘
```

### 方案优势

1. ✅ **完全免费** - ML Kit免费,自定义算法无成本
2. ✅ **离线可用** - 不需要网络连接
3. ✅ **实现简单** - ML Kit易于集成,自定义算法不复杂
4. ✅ **性能优秀** - 针对移动端优化
5. ✅ **满足所有需求** - 完美解决客户的所有要求

---

## 🧮 核心算法设计

### 1. 人脸评分算法

**评分维度**:
1. **人脸大小 (40%)** - 越大越好,但不能太大
   - 最佳范围: 占画面10%-40%
   - 太小: 看不清
   - 太大: 不完整

2. **正面程度 (30%)** - 越正越好
   - 检测左右转头角度 (Yaw)
   - 检测上下点头角度 (Pitch)
   - 检测左右歪头角度 (Roll)
   - 角度越小越正面

3. **清晰度 (20%)** - 眼睛睁开、表情清晰
   - 左眼睁开概率
   - 右眼睁开概率
   - 微笑概率(可选)

4. **位置 (10%)** - 居中更好
   - 人脸中心与画面中心的距离
   - 越居中越好

**评分公式**:
```
总分 = 大小评分 × 0.4 + 正面评分 × 0.3 + 清晰度评分 × 0.2 + 位置评分 × 0.1
```

---

### 2. 画面清晰度算法

**使用Laplacian算子检测边缘**

**原理**:
- 清晰的画面边缘锐利,Laplacian值大
- 模糊的画面边缘平滑,Laplacian值小

**实现步骤**:
1. 将彩色图像转为灰度图
2. 应用Laplacian算子
3. 计算标准差
4. 标准差越大,画面越清晰

**伪代码**:
```
清晰度 = Laplacian(灰度图).标准差 / 100
```

---

### 3. 画面独特性算法

**使用像素对比检测相似度**

**原理**:
- 相似的画面像素颜色接近
- 独特的画面像素颜色差异大

**实现步骤**:
1. 将两张图片缩小到50x50(提高速度)
2. 逐像素对比颜色差异
3. 计算相似像素的比例
4. 独特性 = 1 - 相似度

**伪代码**:
```
相似度 = 相似像素数 / 总像素数
独特性 = 1 - 相似度
```

---

### 4. 时间分布策略

**确保开头、中间、结尾都有截图**

**时间划分**:
- **开头**: 0% - 10% 的时间段
- **中间**: 40% - 60% 的时间段
- **结尾**: 90% - 100% 的时间段

**选择策略**:
1. 从每个时间段选择评分最高的画面
2. 如果某个时间段没有合适的画面,从其他时间段补充
3. 总共3-5张

---

## 🔄 工作流程

### 完整流程图

```
视频播放开始
    ↓
每秒截取一帧画面
    ↓
检测人脸?
    ├─ 有人脸 → 计算人脸评分
    │   ├─ 大小评分 (40%)
    │   ├─ 正面评分 (30%)
    │   ├─ 清晰评分 (20%)
    │   └─ 位置评分 (10%)
    │
    └─ 无人脸 → 计算画面评分
        ├─ 清晰度 (40%)
        ├─ 独特性 (40%)
        └─ 时间位置 (20%)
    ↓
保存候选画面
    ↓
视频播放结束
    ↓
选择最佳截图
    ├─ 优先人脸画面 (最多2张)
    ├─ 确保开头/中间/结尾都有
    ├─ 总共3-5张
    └─ 按时间排序
    ↓
保存到相册
```

### 详细步骤说明

#### 阶段1: 视频播放期间 - 收集候选画面

1. **启动检测线程**
   - 视频开始播放时启动
   - 每隔1秒截取一帧画面

2. **分析每一帧**
   - 使用ML Kit检测人脸
   - 如果有人脸 → 计算人脸评分
   - 如果无人脸 → 计算画面评分

3. **保存候选画面**
   - 评分超过阈值的画面保存为候选
   - 记录画面、评分、时间戳、类型、位置

#### 阶段2: 视频播放结束 - 选择最佳截图

1. **按评分排序**
   - 将所有候选画面按评分从高到低排序

2. **优先选择人脸**
   - 从高分到低分选择人脸画面
   - 最多选择2张人脸画面

3. **确保时间覆盖**
   - 检查是否有开头、中间、结尾的画面
   - 如果缺少某个位置,从该位置选择最高分画面

4. **补充到3-5张**
   - 如果不足3张,补充高分画面
   - 如果超过5张,只保留前5张

5. **按时间排序**
   - 将选中的画面按时间戳排序
   - 便于查看视频进程

6. **保存到相册**
   - 保存到 Pictures/权利卫士取证/ 目录
   - 文件名包含序号、类型、时间、评分

---

## 💻 核心代码结构

### 主要类和方法

```java
/**
 * 智能取证截图服务
 */
public class SmartEvidenceScreenshotService {

    // 人脸检测器
    private FaceDetector faceDetector;

    // 候选画面列表
    private List<ScreenshotCandidate> candidates;

    // 视频信息
    private int videoDuration;  // 总时长(秒)
    private int currentTime;    // 当前时间(秒)

    /**
     * 启动智能截图
     */
    public void startSmartScreenshot(int videoDuration);

    /**
     * 分析画面并评分
     */
    private void analyzeFrame(Bitmap frame, int timestamp);

    /**
     * 分析有人脸的画面
     */
    private void analyzeFaceFrame(Bitmap frame, List<Face> faces, int timestamp);

    /**
     * 计算人脸评分
     */
    private float calculateFaceScore(Face face, int frameWidth, int frameHeight);

    /**
     * 分析无人脸的画面
     */
    private void analyzeSceneFrame(Bitmap frame, int timestamp);

    /**
     * 计算画面特征评分
     */
    private float calculateSceneScore(Bitmap frame, int timestamp);

    /**
     * 计算画面清晰度
     */
    private float calculateSharpness(Bitmap bitmap);

    /**
     * 计算画面独特性
     */
    private float calculateUniqueness(Bitmap frame);

    /**
     * 计算两张图片的相似度
     */
    private float calculateSimilarity(Bitmap bmp1, Bitmap bmp2);

    /**
     * 选择最佳截图
     */
    private void selectBestScreenshots();

    /**
     * 确保特定位置有截图
     */
    private void ensurePositionCoverage(List<ScreenshotCandidate> selected, String position);

    /**
     * 保存选中的截图
     */
    private void saveSelectedScreenshots(List<ScreenshotCandidate> selected);
}

/**
 * 截图候选
 */
class ScreenshotCandidate {
    Bitmap bitmap;      // 画面
    float score;        // 评分
    int timestamp;      // 时间戳(秒)
    String type;        // 类型: "face" 或 "scene"
    String position;    // 位置: "opening", "middle", "ending"
}
```

---

## 📅 开发计划

### 阶段1: 基础功能实现 (2-3天)

**任务**:
1. ✅ 集成Google ML Kit Face Detection
2. ✅ 实现人脸检测和评分
3. ✅ 实现画面清晰度检测
4. ✅ 实现画面相似度对比
5. ✅ 实现候选画面收集

**交付物**:
- 可以检测人脸并评分
- 可以检测画面清晰度
- 可以收集候选画面

---

### 阶段2: 智能选择算法 (1-2天)

**任务**:
1. ✅ 实现时间分布策略
2. ✅ 实现最佳画面选择算法
3. ✅ 实现截图保存功能
4. ✅ 添加日志记录

**交付物**:
- 可以自动选择3-5张最佳截图
- 确保开头、中间、结尾都有
- 保存到相册

---

### 阶段3: 测试和优化 (2-3天)

**任务**:
1. ✅ 在真实视频上测试
2. ✅ 调整评分参数
3. ✅ 优化性能
4. ✅ 处理边界情况

**测试场景**:
- 有人脸的视频
- 无人脸的视频
- 短视频(15秒)
- 长视频(1分钟+)
- 多人脸视频
- 人脸不清晰的视频

**优化目标**:
- 准确率 > 90%
- 处理速度 < 2秒/帧
- 内存占用 < 100MB

---

### 阶段4: 集成到主流程 (1天)

**任务**:
1. ✅ 集成到自动化流程
2. ✅ 添加UI控制
3. ✅ 更新文档
4. ✅ 发布新版本

**交付物**:
- 完整的自动化取证流程
- 用户可以启用/禁用智能截图
- 完整的使用文档

---

## 🔧 技术细节

### 1. 如何截取视频画面

**方案A: 使用MediaProjection API (推荐)**

```java
// 在无障碍服务中截取屏幕
private Bitmap captureCurrentFrame() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
        // Android 11+ 使用新API
        // 需要在MainActivity中实现
        return captureScreenWithMediaProjection();
    } else {
        // Android 10及以下使用旧方法
        return captureScreenWithAccessibility();
    }
}
```

**方案B: 使用AccessibilityService截图**

```java
// 通过无障碍服务获取窗口内容
private Bitmap captureScreenWithAccessibility() {
    AccessibilityNodeInfo rootNode = getRootInActiveWindow();
    if (rootNode == null) return null;

    // 获取窗口截图
    // 注意: 需要特殊权限
    return takeScreenshotFromNode(rootNode);
}
```

---

### 2. 如何获取视频时长

**方案A: 从UI中读取**

```java
// 从抖音UI中读取视频时长
private int getVideoDuration() {
    AccessibilityNodeInfo rootNode = getRootInActiveWindow();

    // 查找时长显示控件
    List<AccessibilityNodeInfo> timeNodes =
        rootNode.findAccessibilityNodeInfosByViewId("com.ss.android.ugc.aweme:id/time");

    if (timeNodes != null && !timeNodes.isEmpty()) {
        String timeText = timeNodes.get(0).getText().toString();
        // 解析 "00:15" 格式
        return parseTimeToSeconds(timeText);
    }

    return 60; // 默认60秒
}
```

**方案B: 固定时长或用户输入**

```java
// 使用固定时长
private int getVideoDuration() {
    return 60; // 假设所有视频60秒
}
```

---

### 3. 性能优化

**优化1: 降低检测频率**

```java
// 不是每秒都检测,而是每2-3秒检测一次
Thread.sleep(2000); // 2秒间隔
```

**优化2: 缩小图片尺寸**

```java
// 将截图缩小后再分析,提高速度
Bitmap small = Bitmap.createScaledBitmap(frame, 640, 480, false);
analyzeFrame(small, timestamp);
```

**优化3: 异步处理**

```java
// 使用线程池异步处理
ExecutorService executor = Executors.newFixedThreadPool(2);
executor.submit(() -> analyzeFrame(frame, timestamp));
```

**优化4: 及时释放资源**

```java
// 分析完立即释放Bitmap
bitmap.recycle();
```

---

## ⚠️ 注意事项

### 1. 权限要求

- ✅ **无障碍服务权限** - 已有
- ✅ **存储权限** - 已有
- ⚠️ **截屏权限** - 需要用户授权(MediaProjection)

### 2. 兼容性

- ✅ **Android 11+** - 完全支持
- ⚠️ **Android 10** - 部分功能受限
- ❌ **Android 9及以下** - 截屏功能受限

### 3. 性能影响

- **CPU占用**: 中等(图像处理)
- **内存占用**: 中等(保存候选画面)
- **电量消耗**: 中等(持续检测)

**优化建议**:
- 降低检测频率(2-3秒/次)
- 限制候选画面数量(最多20张)
- 及时释放不需要的画面

---

## 🤔 待解决问题

### 1. 如何准确获取视频时长?

**问题**: 不同APP的UI不同,难以通用

**可能方案**:
- 方案A: 从UI中读取(需要适配不同APP)
- 方案B: 用户手动输入
- 方案C: 固定时长(如60秒)
- 方案D: 动态检测(播放到结尾自动停止)

**推荐**: 方案D - 动态检测

---

### 2. 如何判断视频播放结束?

**问题**: 需要知道何时停止检测

**可能方案**:
- 方案A: 检测播放进度条到达100%
- 方案B: 检测"重播"按钮出现
- 方案C: 固定时长后自动停止
- 方案D: 用户手动停止

**推荐**: 方案A + 方案D 组合

---

### 3. 如何处理多人脸场景?

**问题**: 一个画面中有多个人脸

**可能方案**:
- 方案A: 选择最大的人脸
- 方案B: 选择最正面的人脸
- 方案C: 选择评分最高的人脸
- 方案D: 截取包含所有人脸的画面

**推荐**: 方案C - 选择评分最高的人脸

---

### 4. 如何识别"落款"?

**问题**: 季老师提到"结尾的落款"

**可能方案**:
- 方案A: 使用OCR识别文字
- 方案B: 检测画面中的文字区域
- 方案C: 固定截取结尾画面
- 方案D: 检测画面变化(落款通常是静止画面)

**推荐**: 方案A + 方案C 组合

---

## 📚 参考资料

### 官方文档

1. **Google ML Kit Face Detection**
   - https://developers.google.com/ml-kit/vision/face-detection

2. **Google ML Kit Text Recognition**
   - https://developers.google.com/ml-kit/vision/text-recognition

3. **Android MediaProjection API**
   - https://developer.android.com/reference/android/media/projection/MediaProjection

4. **Android AccessibilityService**
   - https://developer.android.com/reference/android/accessibilityservice/AccessibilityService

### 技术文章

1. **图像清晰度检测算法**
   - Laplacian算子原理和应用

2. **图像相似度对比算法**
   - 直方图对比
   - 特征点匹配
   - 感知哈希算法

3. **人脸检测最佳实践**
   - 人脸质量评估
   - 多人脸处理
   - 性能优化

---

## 📝 总结

### 核心技术栈

```
Google ML Kit Face Detection (人脸检测)
+
Laplacian算子 (清晰度检测)
+
像素对比算法 (相似度检测)
+
智能评分系统 (画面选择)
+
时间分布策略 (全面覆盖)
```

### 预期效果

1. ✅ **有人脸**: 自动截取正面、清晰、大小合适的人脸画面
2. ✅ **无人脸**: 自动截取最独特、最清晰的画面
3. ✅ **时间覆盖**: 确保开头、中间、结尾都有截图
4. ✅ **数量控制**: 自动选择3-5张最佳画面
5. ✅ **完全自动**: 无需人工干预

### 开发周期

- **总计**: 6-10天
- **基础功能**: 2-3天
- **智能算法**: 1-2天
- **测试优化**: 2-3天
- **集成发布**: 1天

### 技术难度

- **整体难度**: 中等
- **ML Kit集成**: 简单
- **算法实现**: 中等
- **性能优化**: 中等

---

## 🔗 相关文档

- [README.md](../README.md) - 项目总览
- [开发指南.md](./开发指南.md) - 开发规范
- [自动化文档.md](./自动化文档.md) - 自动化流程
- [常见问题.md](./常见问题.md) - FAQ

---

**文档状态**: 设计完成,待实现

**下一步**: 等待刀仔老板确认后开始开发

---

