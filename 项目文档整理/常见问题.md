# 常见问题 (FAQ)

[← 返回README](../README.md)

---

## 📋 目录

1. [安装和配置问题](#安装和配置问题)
2. [权限相关问题](#权限相关问题)
3. [自动化运行问题](#自动化运行问题)
4. [系统录屏权限弹窗问题](#系统录屏权限弹窗问题)
5. [vivo设备专属问题](#vivo设备专属问题)
6. [录屏相关问题](#录屏相关问题)
7. [性能和稳定性问题](#性能和稳定性问题)
8. [坐标点击问题](#坐标点击问题)

---

## 🔧 安装和配置问题

### Q1: 如何安装自动化APK?

**A**: 
1. 下载APK文件到手机
2. 打开文件管理器,找到APK文件
3. 点击安装 (如果提示"未知来源",需要在设置中允许)
4. 安装完成后打开应用

**注意**: 部分手机需要在设置中开启"允许安装未知来源应用"

---

### Q2: 安装后无法打开应用?

**可能原因**:
- 系统版本过低 (需要Android 8.0+)
- APK文件损坏
- 签名验证失败

**解决方案**:
1. 检查Android版本: 设置 > 关于手机 > Android版本
2. 重新下载APK文件
3. 卸载后重新安装
4. 查看系统日志: `adb logcat | grep AndroidRuntime`

---

### Q3: 应用闪退怎么办?

**排查步骤**:
1. 检查是否授予了必要权限
2. 检查是否安装了权利卫士应用
3. 清除应用数据后重试
4. 查看崩溃日志

**查看崩溃日志**:
```bash
adb logcat -b crash
```

---

## 🔐 权限相关问题

### Q4: 如何开启无障碍服务?

**vivo设备**:
1. 打开 设置
2. 进入 更多设置
3. 选择 无障碍
4. 选择 已安装的服务
5. 找到"权利卫士自动化"
6. 打开开关并确认

**其他设备**:
1. 打开 设置
2. 搜索"无障碍"
3. 找到"权利卫士自动化"
4. 打开开关

**验证方法**:
```bash
adb shell settings get secure enabled_accessibility_services
```

---

### Q5: 无障碍服务自动关闭?

**原因**:
- 系统安全策略
- 应用被系统杀死
- 电池优化限制

**解决方案**:
1. 关闭电池优化 (见Q10)
2. 开启自启动权限 (见Q11)
3. 锁定应用在后台
4. 添加到白名单

---

### Q6: 如何开启悬浮窗权限?

**vivo设备**:
1. 设置 > 应用与权限 > 权限管理
2. 选择"悬浮窗"
3. 找到"权利卫士自动化"
4. 选择"允许"

**验证方法**:
```bash
adb shell appops get <包名> SYSTEM_ALERT_WINDOW
```

---

## 🤖 自动化运行问题

### Q7: 自动化无法启动权利卫士?

**检查清单**:
- [ ] 权利卫士是否已安装
- [ ] 包名是否正确 (com.unitrust.tsa)
- [ ] 无障碍服务是否开启
- [ ] 是否有启动其他应用的权限

**常见原因和解决方案**:

#### 原因1: getLaunchIntentForPackage返回null

**现象**: 日志显示"方法1失败,尝试方法2"

**原因**: `PackageManager.getLaunchIntentForPackage()`在某些情况下会返回null

**解决方案**: 使用显式Intent
```java
// ❌ 不可靠的方法
Intent intent = getPackageManager().getLaunchIntentForPackage(TARGET_PACKAGE);

// ✅ 可靠的方法
Intent intent = new Intent();
intent.setClassName(TARGET_PACKAGE, TARGET_ACTIVITY);
intent.setAction(Intent.ACTION_MAIN);
intent.addCategory(Intent.CATEGORY_LAUNCHER);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
startActivity(intent);
```

#### 原因2: Activity名称错误

**现象**: 应用无法启动或启动后立即崩溃

**正确的Activity名称**:
```java
private static final String TARGET_PACKAGE = "com.unitrust.tsa";
private static final String TARGET_ACTIVITY = "cn.tsa.activity.SplashActivity";
```

**查找Activity名称的方法**:
```bash
# 查看应用的启动Activity
adb shell dumpsys package com.unitrust.tsa | grep -A5 "android.intent.action.MAIN"
```

#### 原因3: 无障碍服务没有权限执行shell命令

**现象**: 使用`Runtime.exec()`执行am start命令无效

**解决方案**: 使用`startActivity()`而不是shell命令
```java
// ❌ 可能无效
Runtime.getRuntime().exec("am start -n com.unitrust.tsa/cn.tsa.activity.SplashActivity");

// ✅ 推荐方法
Intent intent = new Intent();
intent.setClassName("com.unitrust.tsa", "cn.tsa.activity.SplashActivity");
startActivity(intent);
```

**手动测试**:
```bash
# 检查应用是否安装
adb shell pm list packages | grep unitrust

# 手动启动应用
adb shell am start -n com.unitrust.tsa/cn.tsa.activity.SplashActivity

# 查看日志
adb logcat | grep "AutomationService"
```

---

## 🎬 系统录屏权限弹窗问题

### Q7.0: 系统录屏权限弹窗无法自动点击"立即开始"?

**现象**:
- 点击录屏按钮后,系统弹出录屏权限对话框
- 对话框显示"立即开始"按钮,但是无法自动点击
- 或者点击了"继续"按钮而不是"立即开始"

**问题分析**:

系统录屏权限弹窗有两种状态:
1. **状态1**: 下拉框显示"单个应用",按钮显示"继续"
2. **状态2**: 下拉框显示"整个屏幕",按钮显示"立即开始"

**常见问题**:

#### 问题1: 按钮文本无法通过getText()获取

**原因**:
- 系统对话框的按钮文本可能显示在子节点上
- `getText()`和`getContentDescription()`都可能返回空或旧值

**解决方案**: 通过按钮ID识别
```java
// ✅ 通过ID识别button1(系统对话框标准确认按钮)
if (viewId != null && viewId.endsWith("button1")) {
    logD("🎯 找到系统对话框确认按钮");
    node.performAction(ACTION_CLICK);
}
```

#### 问题2: 点击"单个应用"后立即执行后续代码

**原因**:
- 点击下拉框后,如果不return,会继续执行后面的代码
- 导致在下拉菜单还没展开时就尝试点击按钮

**解决方案**: 点击后立即return
```java
if (clicked) {
    logD("✅ 成功点击'单个应用'下拉框");

    // 在新线程中等待1500ms后点击"整个屏幕"
    new Thread(() -> {
        Thread.sleep(1500);
        clickWholeScreenOption();
    }).start();

    // 重要: 立即返回,不要继续执行后面的代码!
    rootNode.recycle();
    return;
}
```

#### 问题3: 等待时间不够导致界面未更新

**原因**:
- 点击"整个屏幕"后,界面需要时间更新
- 如果等待时间太短,按钮还是"继续"状态

**解决方案**: 合理的等待时间
```java
// 点击"单个应用"后等待1500ms
Thread.sleep(1500);

// 点击"整个屏幕"后等待1000ms
Thread.sleep(1000);

// 检测重试间隔800ms,共3次
for (int i = 0; i < 3; i++) {
    findAndClickStartButton();
    Thread.sleep(800);
}
```

**完整解决方案 (V1.4)**:

```java
// 1. 查找"单个应用"并点击
List<AccessibilityNodeInfo> spinnerNodes =
    rootNode.findAccessibilityNodeInfosByText("单个应用");

if (spinnerNodes != null && !spinnerNodes.isEmpty()) {
    boolean clicked = spinnerNodes.get(0).performAction(ACTION_CLICK);

    if (clicked) {
        // 等待1500ms后点击"整个屏幕"
        new Thread(() -> {
            Thread.sleep(1500);
            clickWholeScreenOption();
        }).start();

        // 立即返回!
        return;
    }
}

// 2. 点击"整个屏幕"后,通过ID查找button1
private void findAndClickStartButton(AccessibilityNodeInfo node) {
    String viewId = node.getViewIdResourceName();

    // 直接通过ID识别button1
    if (viewId != null && viewId.endsWith("button1")) {
        node.performAction(ACTION_CLICK);
        logD("🎉 成功点击确认按钮,录屏即将开始!");
    }
}
```

**验证方法**:

查看日志输出:
```
✅ 成功点击'单个应用'下拉框,等待下拉菜单展开...
找到'整个屏幕'文本节点
✅ 成功点击'整个屏幕'选项,等待界面更新...
⏳ 等待1秒,让界面完全更新...
🔍 第1次检测'立即开始'按钮
📋 扫描当前界面的按钮:
  🔘 [Button] 文本='(无)' 描述='继续' ID='button1'
🎯 找到系统对话框确认按钮: ID='button1'
🎉 成功点击确认按钮,录屏即将开始!
```

---

### Q7.1: 编译时出现D8编译器NullPointerException错误?

**错误信息**:
```
> Task :app:dexBuilderDebug FAILED
Caused by: com.android.builder.dexing.DexArchiveBuilderException:
  Failed to process: .../LogActivity$ScrollToBottomRunnable.class
Caused by: com.android.tools.r8.CompilationFailedException:
  Compilation failed to complete
Caused by: java.lang.NullPointerException

BUILD FAILED
```

**问题原因**:

Android Gradle Plugin 7.4.2的D8编译器在处理**内部类**(无论匿名还是命名)时存在严重bug,会导致NullPointerException崩溃。

**尝试过的失败方案**:

1. ❌ **改为命名内部类** - 无效,同样报错
2. ❌ **升级AGP到8.7.3** - 需要Java 17,环境配置复杂
3. ❌ **禁用调试信息** (`-g:none`) - 无效

**✅ 最终解决方案: 使用Lambda表达式**

Lambda表达式的字节码结构与传统内部类不同,可以完美绕过D8的bug!

**代码对比**:

```java
// ❌ 匿名内部类 - 会导致D8崩溃
handler.postDelayed(new Runnable() {
    @Override
    public void run() {
        updateLogDisplay();
    }
}, 1000);

// ❌ 命名内部类 - 同样会导致D8崩溃
private class UpdateLogRunnable implements Runnable {
    @Override
    public void run() {
        updateLogDisplay();
    }
}

// ✅ Lambda表达式 - 完美解决!
handler.postDelayed(() -> {
    updateLogDisplay();
}, 1000);

// ✅ 对话框监听器也用Lambda
builder.setPositiveButton(R.string.dialog_confirm,
    (dialog, which) -> clearLog());

// ✅ 滚动操作也用Lambda
scrollView.post(() -> scrollView.fullScroll(View.FOCUS_DOWN));
```

**编译环境配置**:

如果遇到"Unable to locate a Java Runtime"错误,需要设置JAVA_HOME:

```bash
# 方法1: 使用Android Studio的JDK
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
./gradlew assembleDebug

# 方法2: 创建编译脚本 (推荐)
chmod +x build.sh
./build.sh
```

**build.sh脚本内容**:
```bash
#!/bin/bash
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
./gradlew clean assembleDebug
```

**技术细节**:

- **Lambda表达式** (Java 8+) 编译为`invokedynamic`指令
- **匿名/命名内部类** 编译为独立的`.class`文件
- D8编译器在处理内部类的`.class`文件时会触发NullPointerException
- Lambda表达式不生成独立的`.class`文件,因此不会触发bug

**适用场景**:

所有需要使用Runnable、Listener等接口的地方,都应该优先使用Lambda表达式:

```java
// ✅ Handler延迟任务
handler.postDelayed(() -> doSomething(), 1000);

// ✅ 线程
new Thread(() -> doBackgroundWork()).start();

// ✅ 点击监听器
button.setOnClickListener(v -> handleClick());

// ✅ 对话框按钮
builder.setPositiveButton("确定", (d, w) -> confirm());
```

**注意事项**:

1. Lambda表达式需要Java 8支持,确保`build.gradle`中配置:
```gradle
compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
```

2. 如果必须使用内部类(如需要保存状态),考虑升级AGP到8.x版本

---

### Q8: 找不到"开始录屏"按钮?

**可能原因**:
- 界面未加载完成
- Resource ID变化 (应用版本更新)
- 界面布局改变

**排查方法**:
1. 使用UI Automator Viewer查看当前界面
2. 检查Resource ID是否正确
3. 增加等待时间
4. 检查应用版本是否匹配

**临时解决**:
```java
// 增加等待时间
SystemClock.sleep(3000);

// 使用文本查找作为备选方案
List<AccessibilityNodeInfo> nodes = 
    rootNode.findAccessibilityNodeInfosByText("开始录屏取证");
```

---

### Q9: 点击按钮没有反应?

**可能原因**:
- 控件不可点击
- 控件被遮挡
- 点击事件被拦截

**解决方案**:
1. 检查控件是否可点击:
```java
if (node.isClickable()) {
    node.performAction(AccessibilityNodeInfo.ACTION_CLICK);
}
```

2. 尝试点击父节点:
```java
AccessibilityNodeInfo parent = node.getParent();
if (parent != null && parent.isClickable()) {
    parent.performAction(AccessibilityNodeInfo.ACTION_CLICK);
}
```

3. 使用全局手势:
```java
Path path = new Path();
Rect rect = new Rect();
node.getBoundsInScreen(rect);
path.moveTo(rect.centerX(), rect.centerY());

GestureDescription gesture = new GestureDescription.Builder()
    .addStroke(new GestureDescription.StrokeDescription(path, 0, 100))
    .build();

dispatchGesture(gesture, null, null);
```

---

## 📱 vivo设备专属问题

### Q10: 如何关闭vivo设备的电池优化?

**步骤**:
1. 打开 设置
2. 进入 电池
3. 选择 后台高耗电
4. 找到"权利卫士自动化"
5. 选择"允许"

**或者**:
1. 设置 > 应用与权限 > 应用管理
2. 找到"权利卫士自动化"
3. 电池 > 后台耗电管理
4. 选择"允许后台高耗电"

**验证方法**:
```bash
adb shell dumpsys deviceidle whitelist | grep <包名>
```

---

### Q11: 如何开启vivo设备的自启动?

**步骤**:
1. 设置 > 应用与权限
2. 选择 自启动
3. 找到"权利卫士自动化"
4. 打开开关

**重要**: 同时需要开启"权利卫士"的自启动

---

### Q12: vivo设备后台应用被杀死?

**完整配置清单**:

1. **自启动**: 设置 > 应用与权限 > 自启动 > 允许
2. **后台高耗电**: 设置 > 电池 > 后台高耗电 > 允许
3. **后台弹出界面**: 设置 > 应用与权限 > 应用管理 > 权限 > 后台弹出界面 > 允许
4. **锁定后台**: 多任务界面下拉应用卡片锁定
5. **关闭省电模式**: 设置 > 电池 > 省电模式 > 关闭

**终极方案**:
```bash
# 通过ADB禁用电池优化
adb shell dumpsys deviceidle whitelist +<包名>
```

---

### Q13: vivo设备无障碍服务频繁断开?

**原因**: vivo的Funtouch OS对无障碍服务管控严格

**解决方案**:
1. 完成Q10-Q12的所有配置
2. 在开发者选项中关闭"不保留活动"
3. 在开发者选项中设置"后台进程限制"为"标准限制"
4. 重启设备后重新开启无障碍服务

**开发者选项设置**:
```
设置 > 系统管理 > 开发者选项
- 不保留活动: 关闭
- 后台进程限制: 标准限制
```

---

## 📹 录屏相关问题

### Q13.5: 应用验真界面如何自动选择抖音并截屏?

**问题描述**:
录屏开始后会弹出"应用验真"界面,需要选择要验证的应用(如抖音),并在点击"立即验证"前截屏保存。

**自动化处理流程**:

1️⃣ **检测应用验真界面** - 通过"应用验真"标题识别

2️⃣ **查找抖音容器** - 通过ID `rl_douyin` 直接定位

3️⃣ **点击抖音图标** - 自动勾选抖音

4️⃣ **随机延迟1-3秒** - 模拟真实用户操作

5️⃣ **截屏保存** - 保存应用验真页面到相册

6️⃣ **点击立即验证** - 完成验证流程

**技术实现**:

```java
// 1. 查找抖音容器并点击
List<AccessibilityNodeInfo> douyinContainerNodes =
    rootNode.findAccessibilityNodeInfosByViewId("com.unitrust.tsa:id/rl_douyin");

if (douyinContainerNodes != null && !douyinContainerNodes.isEmpty()) {
    AccessibilityNodeInfo douyinIcon = douyinContainerNodes.get(0);
    boolean clicked = douyinIcon.performAction(ACTION_CLICK);

    if (clicked) {
        hasSelectedDouyin = true; // 阻止主循环重复点击

        // 2. 随机延迟1-3秒
        new Thread(() -> {
            int randomDelay = 1000 + new Random().nextInt(2000);
            Thread.sleep(randomDelay);

            // 3. 截屏并点击"立即验证"
            clickVerifyButton();
        }).start();
    }
}

// 4. 截屏保存到相册
private void takeScreenshotBeforeVerify(ScreenshotCallback callback) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
        takeScreenshot(Display.DEFAULT_DISPLAY, getMainExecutor(),
            new TakeScreenshotCallback() {
                @Override
                public void onSuccess(ScreenshotResult result) {
                    Bitmap bitmap = Bitmap.wrapHardwareBuffer(
                        result.getHardwareBuffer(),
                        result.getColorSpace()
                    );
                    saveScreenshot(bitmap);
                    callback.onSuccess();
                }
            }
        );
    }
}

// 5. 保存到公共相册
private void saveScreenshot(Bitmap bitmap) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        // Android 10+ 使用MediaStore
        ContentValues values = new ContentValues();
        values.put(MediaStore.Images.Media.DISPLAY_NAME, fileName);
        values.put(MediaStore.Images.Media.RELATIVE_PATH,
                  Environment.DIRECTORY_PICTURES + "/权利卫士取证");

        Uri imageUri = resolver.insert(
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values
        );

        OutputStream os = resolver.openOutputStream(imageUri);
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, os);
    }
}
```

**关键技术点**:

1. **阻止重复点击**: 使用`hasSelectedDouyin`标志,防止主循环在延迟期间重复点击"立即验证"
2. **同步等待截屏**: 使用`CountDownLatch`确保截屏完成后再点击按钮
3. **截屏权限**: 需要在`accessibility_service_config.xml`中声明`android:canTakeScreenshot="true"`
4. **保存到相册**: 使用MediaStore API保存到公共相册,方便查看

**截图保存位置**:
```
相册 / Pictures / 权利卫士取证 / 应用验真_袁丹-抖音_海赫Hayhoe服饰_20250120_200530.png
```

**注意事项**:
- 截屏功能需要Android 11+ (API 30+)
- 首次使用需要授予存储权限
- 截图会自动保存到相册的"权利卫士取证"文件夹

**日志输出示例**:
```
🎯 检测到应用验真界面
✅ 找到抖音容器(ID: rl_douyin)
✅ 成功点击抖音容器
⏳ 等待 2.3 秒后点击'立即验证'...
📸 准备截屏保存应用验真页面...
✅ 截屏API调用成功!
✅ 截图已保存到相册: Pictures/权利卫士取证/应用验真_xxx.png
🎯 找到'立即验证'按钮,准备点击...
🎉 成功点击'立即验证'按钮!
```

---

### Q14: 打开抖音时弹出"打开看看"页面怎么办? (V2.0已解决)

**问题描述**:
- 录屏开始后,需要先录制律师的取证资质
- 打开抖音后需要进入"我"-"设置"-"资质证照"
- 但是剪贴板里有取证信息(包含抖音链接)
- 打开抖音时会自动弹出"打开看看"页面
- 这个弹窗会被录制进去,不符合取证流程!

**问题原因**:
- 用户粘贴取证信息后,剪贴板里包含抖音分享链接
- 抖音应用会自动检测剪贴板内容
- 如果发现抖音链接,会弹出"打开看看"口令打开页面

**解决方案 (V2.0)**:

系统会在开始录屏前自动清空剪贴板,避免弹出"打开看看"页面!

**技术实现**:
```java
/**
 * 清空剪贴板
 * 避免打开抖音时弹出"打开看看"页面
 */
private void clearClipboard() {
    try {
        ClipboardManager clipboard =
            (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

        if (clipboard != null) {
            // 复制一个空文本到剪贴板
            ClipData clip = ClipData.newPlainText("", "");
            clipboard.setPrimaryClip(clip);
            Log.d(TAG, "🧹 已清空剪贴板");
        }
    } catch (Exception e) {
        Log.e(TAG, "清空剪贴板失败: " + e.getMessage());
    }
}

// 在开始自动化时调用
public void startAutomation() {
    // 🎯 关键: 在开始录屏前清空剪贴板
    clearClipboard();

    // 然后打开权利卫士
    minimizeCurrentApp();
    delayedOpenApp();
}
```

**日志输出**:
```
🧹 已清空剪贴板,避免打开抖音时弹出'打开看看'
```

**注意事项**:
- ✅ V2.0版本已自动处理,无需手动操作
- ✅ 清空剪贴板不会影响其他功能
- ✅ 确保录屏过程符合取证流程要求

---

### Q15: 录屏无法开始?

**检查清单**:
- [ ] 权利卫士是否已登录
- [ ] 是否有足够的时间戳额度
- [ ] 网络连接是否正常
- [ ] 存储空间是否充足
- [ ] 是否授予了录屏权限

**手动测试**:
1. 手动打开权利卫士
2. 手动点击开始录屏
3. 观察是否有错误提示

---

### Q15: 录屏中途中断?

**常见原因**:
1. **锁屏** - 录屏过程中锁屏会导致中断
2. **来电** - 接听或拨打电话会中断
3. **内存不足** - 录屏占用大量内存
4. **应用崩溃** - 权利卫士应用崩溃

**预防措施**:
1. 录屏前清理后台应用
2. 确保存储空间充足 (1分钟约20MB)
3. 录屏时不要锁屏
4. 录屏时不要接听电话
5. 建议录屏时长不超过60分钟

---

### Q16: 录屏文件保存在哪里?

**默认路径**:
```
/storage/emulated/0/Android/data/com.unitrust.tsa/files/
```

**查看方法**:
```bash
# 列出录屏文件
adb shell ls -la /storage/emulated/0/Android/data/com.unitrust.tsa/files/

# 导出到电脑
adb pull /storage/emulated/0/Android/data/com.unitrust.tsa/files/xxx.mp4 ./
```

---

### Q17: 系统录屏权限弹窗如何处理?

**问题描述**:
点击"开始录屏"后,系统会弹出录屏权限确认弹窗,需要手动选择"整个屏幕"并点击"立即开始"。

**自动化处理流程**:

本项目已实现完全自动化处理,流程如下:

1️⃣ **检测弹窗** - 监听`com.android.systemui`包的事件

2️⃣ **点击下拉框** - 检测到"单个应用"下拉框时自动点击

3️⃣ **选择整个屏幕** - 在弹出菜单中自动点击"整个屏幕"选项

4️⃣ **点击开始** - 检测到"立即开始"按钮时自动点击

**技术实现**:
```java
// 处理系统录屏权限弹窗
private void handleSystemScreenShareDialog() {
    // 1. 检测"立即开始"按钮
    if (buttonText.contains("立即开始")) {
        buttonNode.performAction(ACTION_CLICK);
        return;
    }

    // 2. 检测"单个应用"下拉框
    if (spinnerText.contains("单个应用")) {
        spinnerNode.performAction(ACTION_CLICK);
        // 等待菜单弹出后点击"整个屏幕"
    }
}

// 智能父节点查找
private void clickWholeScreenOption() {
    // 查找"整个屏幕"文本节点
    List<AccessibilityNodeInfo> nodes =
        rootNode.findAccessibilityNodeInfosByText("整个屏幕");

    // 如果节点不可点击,尝试点击父节点
    if (!node.isClickable()) {
        AccessibilityNodeInfo parent = node.getParent();
        if (parent.isClickable()) {
            parent.performAction(ACTION_CLICK);
        }
    }
}
```

**注意事项**:
- 需要监听`TYPE_WINDOW_STATE_CHANGED`和`TYPE_WINDOW_CONTENT_CHANGED`事件
- 使用智能父节点查找,因为文本节点本身可能不可点击
- 异步处理,避免阻塞主线程

---

### Q18: 如何自动停止录屏?

**方法1: 通过通知栏**
```java
// 监听通知栏的停止按钮
private void clickStopButtonInNotification() {
    // 展开通知栏
    performGlobalAction(GLOBAL_ACTION_NOTIFICATIONS);

    // 等待通知栏展开
    SystemClock.sleep(1000);

    // 查找停止按钮
    AccessibilityNodeInfo rootNode = getRootInActiveWindow();
    List<AccessibilityNodeInfo> nodes =
        rootNode.findAccessibilityNodeInfosByText("停止");

    if (!nodes.isEmpty()) {
        nodes.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);
    }
}
```

**方法2: 返回应用点击停止**
```java
// 启动权利卫士应用
launchRightsGuardApp();

// 等待界面加载
SystemClock.sleep(2000);

// 查找停止按钮
AccessibilityNodeInfo stopButton =
    waitForElement("com.unitrust.tsa:id/btn_stop", 10);

if (stopButton != null) {
    stopButton.performAction(AccessibilityNodeInfo.ACTION_CLICK);
}
```

---

## ⚡ 性能和稳定性问题

### Q18: 自动化运行缓慢?

**优化建议**:

1. **减少不必要的等待**:
```java
// 不好的做法
SystemClock.sleep(5000); // 固定等待5秒

// 好的做法
waitForElement(resourceId, 5); // 最多等待5秒,找到即返回
```

2. **优化UI查找**:
```java
// 不好的做法
List<AccessibilityNodeInfo> nodes =
    rootNode.findAccessibilityNodeInfosByText("开始"); // 遍历整个UI树

// 好的做法
List<AccessibilityNodeInfo> nodes =
    rootNode.findAccessibilityNodeInfosByViewId(resourceId); // 直接定位
```

3. **及时释放资源**:
```java
AccessibilityNodeInfo node = findNode();
try {
    // 使用node
} finally {
    if (node != null) {
        node.recycle(); // 释放资源
    }
}
```

---

### Q19: 内存占用过高?

**原因**:
- AccessibilityNodeInfo未释放
- 日志记录过多
- 缓存数据过多

**解决方案**:
1. 及时调用`node.recycle()`
2. 控制日志输出级别
3. 定期清理缓存
4. 避免保存大量UI节点引用

---

### Q20: 如何提高自动化稳定性?

**最佳实践**:

1. **完善的错误处理**:
```java
try {
    performAutomation();
} catch (Exception e) {
    Log.e(TAG, "自动化失败", e);
    recoverFromError();
}
```

2. **智能重试机制**:
```java
private boolean performActionWithRetry(Runnable action, int maxRetry) {
    for (int i = 0; i < maxRetry; i++) {
        try {
            action.run();
            return true;
        } catch (Exception e) {
            Log.w(TAG, "操作失败,重试: " + (i + 1));
            SystemClock.sleep(1000);
        }
    }
    return false;
}
```

3. **状态监控和恢复**:
```java
// 定期检查应用状态
private void monitorAppHealth() {
    handler.postDelayed(() -> {
        if (!isAppRunning()) {
            Log.w(TAG, "应用异常,尝试恢复");
            recoverFromError();
        }
        monitorAppHealth(); // 继续监控
    }, 5000);
}
```

4. **详细的日志记录**:
```java
Log.d(TAG, "步骤1: 启动应用");
Log.d(TAG, "步骤2: 等待界面加载");
Log.d(TAG, "步骤3: 查找按钮");
Log.d(TAG, "步骤4: 点击按钮");
```

---

## 📤 日志和分享功能

### Q20.5: 如何导出和分享日志?

**功能说明**:
应用内置日志导出和分享功能,可以将运行日志导出为Markdown格式并分享到微信、QQ等应用。

**使用方法**:

**方法1: 右上角导出按钮**
1. 打开应用
2. 点击"查看日志"按钮
3. 点击右上角的**导出图标**(💾)
4. 选择分享目标(微信/QQ等)

**方法2: 底部导出按钮**
1. 打开应用
2. 点击"查看日志"按钮
3. 点击底部的**"导出日志"按钮**
4. 选择分享目标(微信/QQ等)

**导出格式**:

生成的Markdown文件包含:
- 标题: 权利卫士取证自动化 - 运行日志
- 导出时间: 精确到秒
- 日志内容: 代码块格式,便于阅读
- 底部标识: 自动生成标记

**文件保存位置**:
```
/storage/emulated/0/Documents/RightsGuard/Automation_Log_yyyyMMdd_HHmmss.md
```

**分享到微信**:
1. 点击"导出日志"
2. 在分享对话框中选择"微信"
3. 选择好友或群聊
4. 发送文件

**注意事项**:
- 首次使用需要授予存储权限
- 文件会自动保存到Documents/RightsGuard/目录
- 可以在文件管理器中查看历史日志

---

### Q20.6: 日志功能显示"暂时不可用"?

**问题描述**:
点击"查看日志"按钮后,提示"日志功能暂时不可用,请使用logcat查看日志"。

**原因分析**:
这是之前为了修复D8编译器bug临时禁用的日志功能,但是后来忘记重新启用。

**解决方案**:

修改`MainActivity.java`中的日志按钮点击事件:

```java
// ❌ 错误的代码(被禁用)
btnViewLog.setOnClickListener(v -> {
    Toast.makeText(this, "日志功能暂时不可用,请使用logcat查看日志", Toast.LENGTH_SHORT).show();
    // Intent intent = new Intent(MainActivity.this, LogActivity.class);
    // startActivity(intent);
});

// ✅ 正确的代码(已启用)
btnViewLog.setOnClickListener(v -> {
    Intent intent = new Intent(MainActivity.this, LogActivity.class);
    startActivity(intent);
});
```

**验证方法**:
1. 重新编译并安装APK
2. 点击"查看日志"按钮
3. 应该能正常打开日志界面

---

### Q20.7: 编译后修改没有生效?

**问题描述**:
修改了代码并重新编译,但是安装后发现修改没有生效,还是旧的代码。

**原因分析**:
Gradle缓存了旧的`.class`文件,导致编译时使用了缓存而不是最新的源代码。

**解决方案**:

使用`clean`命令清理缓存:

```bash
# 方法1: 清理并编译
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
./gradlew clean assembleDebug
adb install -r -g app/build/outputs/apk/debug/app-debug.apk

# 方法2: 使用Android Studio
# Build > Clean Project
# Build > Rebuild Project
```

**什么时候需要clean**:
1. 修改了代码但编译后没有生效
2. 遇到奇怪的编译错误
3. 切换了分支或合并了代码
4. 修改了资源文件但没有更新
5. 怀疑缓存有问题时

**注意事项**:
- `clean`会删除所有编译产物,下次编译会比较慢
- 建议在确认修改没有生效时再使用
- 可以在编译脚本中加入`clean`命令

**编译脚本示例**:
```bash
#!/bin/bash
# build.sh

export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"

# 清理缓存
./gradlew clean

# 编译APK
./gradlew assembleDebug

# 安装到设备
adb install -r -g app/build/outputs/apk/debug/app-debug.apk

echo "✅ 编译和安装完成!"
```

---

## 🔍 调试技巧

### Q21: 如何查看实时日志?

**方法1: Android Studio**
1. 连接设备
2. 打开Logcat窗口
3. 过滤包名或TAG

**方法2: ADB命令**
```bash
# 实时查看日志
adb logcat | grep "AutomationService"

# 保存日志到文件
adb logcat > automation.log

# 只看错误日志
adb logcat *:E
```

---

### Q22: 如何分析UI结构?

**工具1: UI Automator Viewer**
```bash
cd $ANDROID_HOME/tools/bin
./uiautomatorviewer
```

**工具2: Layout Inspector (Android Studio)**
1. Tools > Layout Inspector
2. 选择设备和进程
3. 查看UI层级

**工具3: ADB命令**
```bash
# 导出UI层级
adb shell uiautomator dump /sdcard/ui.xml
adb pull /sdcard/ui.xml
```

---

### Q23: 如何测试特定功能?

**单元测试示例**:
```java
@Test
public void testFindStartButton() {
    // 模拟场景
    AccessibilityNodeInfo mockRoot = createMockUI();

    // 执行测试
    AccessibilityNodeInfo button = findStartButton(mockRoot);

    // 验证结果
    assertNotNull(button);
    assertEquals("开始录屏取证", button.getText());
}
```

**集成测试**:
1. 安装应用到真机
2. 开启无障碍服务
3. 运行自动化流程
4. 观察日志和结果

---

## 📞 获取帮助

### 遇到问题怎么办?

1. **查看文档**:
   - [开发指南](./开发指南.md)
   - [自动化文档](./自动化文档.md)

2. **查看日志**:
   ```bash
   adb logcat | grep -E "AutomationService|AndroidRuntime"
   ```

3. **检查环境**:
   - Android版本
   - 应用版本
   - 权限配置

4. **提供信息**:
   - 设备型号和系统版本
   - 应用版本
   - 错误日志
   - 复现步骤

---

## 🎯 坐标点击问题

### Q1: 点击"我"按钮没有反应?

**问题原因**:
- 使用 `Runtime.getRuntime().exec("input tap x y")` 命令在无障碍服务中没有权限执行

**解决方案**:
- ✅ 使用 `clickByCoordinates(x, y)` 方法
- ✅ 该方法使用无障碍服务的 `dispatchGesture()` API
- ✅ 有完整的权限,可以正常点击

**技术细节**:
```java
// ❌ 错误做法 - 没有权限
Runtime.getRuntime().exec("input tap 972 2273");

// ✅ 正确做法 - 使用无障碍服务API
clickByCoordinates(972, 2273);
```

---

### Q2: 坐标点击不准确?

**排查步骤**:
1. 使用UI Dump工具查看实际坐标
2. 计算元素中心点: `中心X = (left + right) / 2`, `中心Y = (top + bottom) / 2`
3. 更新代码中的坐标值
4. 重新编译测试

**示例**:
```
元素Bounds: [864,2201] → [1080,2346]
中心点: X = (864 + 1080) / 2 = 972
       Y = (2201 + 2346) / 2 = 2273
```

---

### Q3: 点击后没有等待页面加载?

**问题**:
- 点击"我"按钮后立即点击"更多"按钮,导致"更多"按钮还未出现

**解决方案**:
```java
// 点击"我"按钮
clickMeButton();

// 等待"我"页面加载完成
Thread.sleep(2000);

// 再点击"更多"按钮
clickDouyinMoreButton();
```

---

## 🔗 相关文档

- [开发指南](./开发指南.md) - 开发环境和配置
- [自动化文档](./自动化文档.md) - 技术实现细节
- [Git版本记录](./Git版本记录.md) - 版本更新历史

---

[← 返回README](../README.md)

**最后更新**: 2026-02-06

